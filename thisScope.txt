
////////////NOTES///////////////////////////////////////
Watch MOSH video for this

/////////LINK to understand this//////////////////////////////////////////
https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work
//////////////////////////////////////////////////////////////////////////
1.Arrow functions don't have their own this.... binding.
 Instead, those identifiers are resolved in the lexical scope like any other variable.
  That means that inside an arrow function, 
this...refer(s) to the values of this in the environment the arrow function is defined in.

2.If a function is called on an object, such as in obj.myMethod() or the equivalent obj["myMethod"](), 
then ThisBinding is set to the object (obj in the example; §13.2.1). In most other cases,
 ThisBinding is set to the global object (§10.4.3).


 3.  EXAMPLE 1: 
 
  var obj = {
    someData: "a string"
};

function myFun() {
    return this 
}

obj.staticFunction = myFun;

console.log("this is window:", obj.staticFunction() == window);// false
console.log("this is obj:", obj.staticFunction() == obj);// true

// As When calling a function on an object, ThisBinding is set to the object.

EXAMPLE 2:
var obj = {
    myMethod: function () {
        return this; // What is `this` here?
    }
};
var myFun = obj.myMethod;
console.log("this is window:", myFun() == window);// true
console.log("this is obj:", myFun() == obj);//false

//reason: In this example, the JavaScript interpreter enters function code,
 but because myFun/obj.myMethod is not called on an object, ThisBinding is set to window.


 When you use this keyword inside an object method,
  this is bound to the "immediate" enclosing object.

   if you nest the object inside another object,
   then this is bound to the immediate parent.

   ////Another Example/////
   var obj1 = {
    name: "obj1",
}

function returnName() {
    return this + ":" + this.name;
}

obj1.f = returnName; //add method to object
document.write(obj1.f()); //[object Object]:obj1
////////////////////////////////////////////////////////////
var obj = {
  name: "manish",
  age: 20,
};
function greet() {
  console.log(this.name);
}
// invoking greet in the context of user object by using call()
greet.call(obj);

/// call with arugments.
function greet (l1, l2, l3) {
  alert(
    `Hello, my name is ${this.name} and I know ${l1}, ${l2}, and ${l3}`
  )
}

const user = {
  name: 'Tyler',
  age: 27,
}

const languages = ['JavaScript', 'Ruby', 'Python']

greet.call(user, languages[0], languages[1], languages[2])
//This works and it shows how you can pass arguments to a function being invoked with .call.
 However, as you may have noticed, it’s a tad annoying to have to pass in the arguments one by one from our languages array.
  It would be nice if we could just pass in the whole array as the second argument and JavaScript would spread those out for us.
   Well good news for us, this is exactly what .apply does. .apply is the exact same thing as .call, 
   but instead of passing in arguments one by one, you can pass in a single array and 
   it will spread each element in the array out for you as arguments to the function.

   //////////bind()/////////////////////////////////////////////////////////////////////////////
so far under our “Explicit Binding” rule, we’ve learned about .call as well as .apply
which both allow you to invoke a function, 
specifying what the this keyword is going to be referencing inside of that function.
The last part of this rule is .bind. .bind is the exact same as .call
but instead of immediately invoking the function, it’ll return a new function that
 you can invoke at a later time. So if we look at our code from earlier,
  using .bind, it’ll look like this

  example////////////
  function greet (l1, l2, l3) {
  alert(
    `Hello, my name is ${this.name} and I know ${l1}, ${l2}, and ${l3}`
  )
}

const user = {
  name: 'Tyler',
  age: 27,
}

const languages = ['JavaScript', 'Ruby', 'Python']

const newFn = greet.bind(user, languages[0], languages[1], languages[2])
newFn() // alerts "Hello, my name is Tyler and I know JavaScript, Ruby, and Python